/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import * as nestAccessControl from "nest-access-control";
import * as defaultAuthGuard from "../../auth/defaultAuth.guard";
import { FactionService } from "../faction.service";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { FactionCreateInput } from "./FactionCreateInput";
import { Faction } from "./Faction";
import { FactionFindManyArgs } from "./FactionFindManyArgs";
import { FactionWhereUniqueInput } from "./FactionWhereUniqueInput";
import { FactionUpdateInput } from "./FactionUpdateInput";
import { PlayerFactionQuestFindManyArgs } from "../../playerFactionQuest/base/PlayerFactionQuestFindManyArgs";
import { PlayerFactionQuest } from "../../playerFactionQuest/base/PlayerFactionQuest";
import { PlayerFactionQuestWhereUniqueInput } from "../../playerFactionQuest/base/PlayerFactionQuestWhereUniqueInput";
import { PlayerFactionReputationFindManyArgs } from "../../playerFactionReputation/base/PlayerFactionReputationFindManyArgs";
import { PlayerFactionReputation } from "../../playerFactionReputation/base/PlayerFactionReputation";
import { PlayerFactionReputationWhereUniqueInput } from "../../playerFactionReputation/base/PlayerFactionReputationWhereUniqueInput";
import { PlayerFactionSpellFindManyArgs } from "../../playerFactionSpell/base/PlayerFactionSpellFindManyArgs";
import { PlayerFactionSpell } from "../../playerFactionSpell/base/PlayerFactionSpell";
import { PlayerFactionSpellWhereUniqueInput } from "../../playerFactionSpell/base/PlayerFactionSpellWhereUniqueInput";
import { PlayerFactionTitleFindManyArgs } from "../../playerFactionTitle/base/PlayerFactionTitleFindManyArgs";
import { PlayerFactionTitle } from "../../playerFactionTitle/base/PlayerFactionTitle";
import { PlayerFactionTitleWhereUniqueInput } from "../../playerFactionTitle/base/PlayerFactionTitleWhereUniqueInput";

@swagger.ApiBearerAuth()
@common.UseGuards(defaultAuthGuard.DefaultAuthGuard, nestAccessControl.ACGuard)
export class FactionControllerBase {
  constructor(
    protected readonly service: FactionService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}
  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Post()
  @swagger.ApiCreatedResponse({ type: Faction })
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "create",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  @swagger.ApiBody({
    type: FactionCreateInput,
  })
  async createFaction(
    @common.Body() data: FactionCreateInput
  ): Promise<Faction> {
    return await this.service.createFaction({
      data: {
        ...data,

        playerFactionAchievements: data.playerFactionAchievements
          ? {
              connect: data.playerFactionAchievements,
            }
          : undefined,
      },
      select: {
        createdAt: true,
        id: true,

        playerFactionAchievements: {
          select: {
            id: true,
          },
        },

        updatedAt: true,
      },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get()
  @swagger.ApiOkResponse({ type: [Faction] })
  @ApiNestedQuery(FactionFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "read",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async factions(@common.Req() request: Request): Promise<Faction[]> {
    const args = plainToClass(FactionFindManyArgs, request.query);
    return this.service.factions({
      ...args,
      select: {
        createdAt: true,
        id: true,

        playerFactionAchievements: {
          select: {
            id: true,
          },
        },

        updatedAt: true,
      },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: Faction })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "read",
    possession: "own",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async faction(
    @common.Param() params: FactionWhereUniqueInput
  ): Promise<Faction | null> {
    const result = await this.service.faction({
      where: params,
      select: {
        createdAt: true,
        id: true,

        playerFactionAchievements: {
          select: {
            id: true,
          },
        },

        updatedAt: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return result;
  }

  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: Faction })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  @swagger.ApiBody({
    type: FactionUpdateInput,
  })
  async updateFaction(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() data: FactionUpdateInput
  ): Promise<Faction | null> {
    try {
      return await this.service.updateFaction({
        where: params,
        data: {
          ...data,

          playerFactionAchievements: data.playerFactionAchievements
            ? {
                connect: data.playerFactionAchievements,
              }
            : undefined,
        },
        select: {
          createdAt: true,
          id: true,

          playerFactionAchievements: {
            select: {
              id: true,
            },
          },

          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: Faction })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "delete",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async deleteFaction(
    @common.Param() params: FactionWhereUniqueInput
  ): Promise<Faction | null> {
    try {
      return await this.service.deleteFaction({
        where: params,
        select: {
          createdAt: true,
          id: true,

          playerFactionAchievements: {
            select: {
              id: true,
            },
          },

          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/playerFactionQuests")
  @ApiNestedQuery(PlayerFactionQuestFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "PlayerFactionQuest",
    action: "read",
    possession: "any",
  })
  async findPlayerFactionQuests(
    @common.Req() request: Request,
    @common.Param() params: FactionWhereUniqueInput
  ): Promise<PlayerFactionQuest[]> {
    const query = plainToClass(PlayerFactionQuestFindManyArgs, request.query);
    const results = await this.service.findPlayerFactionQuests(params.id, {
      ...query,
      select: {
        createdAt: true,

        faction: {
          select: {
            id: true,
          },
        },

        id: true,

        player: {
          select: {
            id: true,
          },
        },

        questId: true,
        state: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/playerFactionQuests")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async connectPlayerFactionQuests(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionQuestWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionQuests: {
        connect: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/playerFactionQuests")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async updatePlayerFactionQuests(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionQuestWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionQuests: {
        set: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/playerFactionQuests")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async disconnectPlayerFactionQuests(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionQuestWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionQuests: {
        disconnect: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/playerFactionReputations")
  @ApiNestedQuery(PlayerFactionReputationFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "PlayerFactionReputation",
    action: "read",
    possession: "any",
  })
  async findPlayerFactionReputations(
    @common.Req() request: Request,
    @common.Param() params: FactionWhereUniqueInput
  ): Promise<PlayerFactionReputation[]> {
    const query = plainToClass(
      PlayerFactionReputationFindManyArgs,
      request.query
    );
    const results = await this.service.findPlayerFactionReputations(params.id, {
      ...query,
      select: {
        amount: true,
        createdAt: true,

        faction: {
          select: {
            id: true,
          },
        },

        id: true,

        player: {
          select: {
            id: true,
          },
        },

        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/playerFactionReputations")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async connectPlayerFactionReputations(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionReputationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionReputations: {
        connect: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/playerFactionReputations")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async updatePlayerFactionReputations(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionReputationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionReputations: {
        set: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/playerFactionReputations")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async disconnectPlayerFactionReputations(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionReputationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionReputations: {
        disconnect: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/playerFactionSpells")
  @ApiNestedQuery(PlayerFactionSpellFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "PlayerFactionSpell",
    action: "read",
    possession: "any",
  })
  async findPlayerFactionSpells(
    @common.Req() request: Request,
    @common.Param() params: FactionWhereUniqueInput
  ): Promise<PlayerFactionSpell[]> {
    const query = plainToClass(PlayerFactionSpellFindManyArgs, request.query);
    const results = await this.service.findPlayerFactionSpells(params.id, {
      ...query,
      select: {
        createdAt: true,

        faction: {
          select: {
            id: true,
          },
        },

        id: true,

        player: {
          select: {
            id: true,
          },
        },

        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/playerFactionSpells")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async connectPlayerFactionSpells(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionSpellWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionSpells: {
        connect: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/playerFactionSpells")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async updatePlayerFactionSpells(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionSpellWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionSpells: {
        set: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/playerFactionSpells")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async disconnectPlayerFactionSpells(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionSpellWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionSpells: {
        disconnect: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/playerFactionTitles")
  @ApiNestedQuery(PlayerFactionTitleFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "PlayerFactionTitle",
    action: "read",
    possession: "any",
  })
  async findPlayerFactionTitles(
    @common.Req() request: Request,
    @common.Param() params: FactionWhereUniqueInput
  ): Promise<PlayerFactionTitle[]> {
    const query = plainToClass(PlayerFactionTitleFindManyArgs, request.query);
    const results = await this.service.findPlayerFactionTitles(params.id, {
      ...query,
      select: {
        createdAt: true,

        faction: {
          select: {
            id: true,
          },
        },

        id: true,

        player: {
          select: {
            id: true,
          },
        },

        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/playerFactionTitles")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async connectPlayerFactionTitles(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionTitleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionTitles: {
        connect: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/playerFactionTitles")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async updatePlayerFactionTitles(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionTitleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionTitles: {
        set: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/playerFactionTitles")
  @nestAccessControl.UseRoles({
    resource: "Faction",
    action: "update",
    possession: "any",
  })
  async disconnectPlayerFactionTitles(
    @common.Param() params: FactionWhereUniqueInput,
    @common.Body() body: PlayerFactionTitleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      playerFactionTitles: {
        disconnect: body,
      },
    };
    await this.service.updateFaction({
      where: params,
      data,
      select: { id: true },
    });
  }
}
